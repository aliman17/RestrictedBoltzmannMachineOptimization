# Intercept
k = 1
ci.intercept <- boot.ci(bst.params, conf=alpha, type="basic", index=k)
# x2
k = 2
ci.x2 <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
# x3
k = 3
ci.x3 <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
ci.intercept <- c(ci.intercept$basic[4], ci.intercept$basic[5])
ci.x2 <- c(ci.x2$basic[4], ci.x2$basic[5])
ci.x3 <- c(ci.x3$basic[4], ci.x3$basic[5])
cis <- t(as.matrix(ci.intercept))
cis <- rbind(cis, ci.x2)
cis <- rbind(cis, ci.x3)
cis
}
ci1 <- list()
ci2 <- list()
ci3 <- list()
for (i in 1:n){
ci1[[i]] <- use.boot.ci(datasets1[[i]], alpha)
ci2[[i]] <- use.boot.ci(datasets2[[i]], alpha)
ci3[[i]] <- use.boot.ci(datasets3[[i]], alpha)
}
counter <- coverage(ci1) + coverage(ci2) + coverage(ci3)
counter/(9*n)
library(boot)
# Our own regression function, which returns coefficients
# which is the same as before
lmcoefs <- function(data, ind) {
d <- as.matrix(data)[ind,,drop=FALSE]
coef(lm.fit(cbind(1, d[,c("x2","x3")]), d[,"y"]))
}
use.boot.ci <- function(data, alpha){
# Get bootstrap samples
bst.params <- boot(data=dataset1, statistic=lmcoefs, R=B)
# Intercept
k = 1
ci.intercept <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
# x2
k = 2
ci.x2 <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
# x3
k = 3
ci.x3 <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
ci.intercept <- c(ci.intercept$basic[4], ci.intercept$basic[5])
ci.x2 <- c(ci.x2$basic[4], ci.x2$basic[5])
ci.x3 <- c(ci.x3$basic[4], ci.x3$basic[5])
cis <- t(as.matrix(ci.intercept))
cis <- rbind(cis, ci.x2)
cis <- rbind(cis, ci.x3)
cis
}
ci1 <- list()
ci2 <- list()
ci3 <- list()
alpha <- 0.001
for (i in 1:n){
ci1[[i]] <- use.boot.ci(datasets1[[i]], alpha)
ci2[[i]] <- use.boot.ci(datasets2[[i]], alpha)
ci3[[i]] <- use.boot.ci(datasets3[[i]], alpha)
}
counter <- coverage(ci1) + coverage(ci2) + coverage(ci3)
counter/(9*n)
library(boot)
# Our own regression function, which returns coefficients
# which is the same as before
lmcoefs <- function(data, ind) {
d <- as.matrix(data)[ind,,drop=FALSE]
coef(lm.fit(cbind(1, d[,c("x2","x3")]), d[,"y"]))
}
use.boot.ci <- function(data, alpha){
# Get bootstrap samples
bst.params <- boot(data=dataset1, statistic=lmcoefs, R=B)
# Intercept
k = 1
ci.intercept <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
# x2
k = 2
ci.x2 <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
# x3
k = 3
ci.x3 <- boot.ci(bst.params, conf=1-alpha, type="basic", index=k)
ci.intercept <- c(ci.intercept$basic[4], ci.intercept$basic[5])
ci.x2 <- c(ci.x2$basic[4], ci.x2$basic[5])
ci.x3 <- c(ci.x3$basic[4], ci.x3$basic[5])
cis <- t(as.matrix(ci.intercept))
cis <- rbind(cis, ci.x2)
cis <- rbind(cis, ci.x3)
cis
}
ci1 <- list()
ci2 <- list()
ci3 <- list()
alpha <- 0.1
for (i in 1:n){
ci1[[i]] <- use.boot.ci(datasets1[[i]], alpha)
ci2[[i]] <- use.boot.ci(datasets2[[i]], alpha)
ci3[[i]] <- use.boot.ci(datasets3[[i]], alpha)
}
counter <- coverage(ci1) + coverage(ci2) + coverage(ci3)
counter/(9*n)
ci2
coverage(ci2)
coverage(ci3)
coverage(ci1)
coverage(ci1)
coverage(ci2)
plot(ci1[1])
ci1[1]
ci1[, 1]
plt <- function(ci, k, l){
n <- c()
for(i in 1:n){
c[i] <- ci[[i]][k,l]
}
c
}
plot(ci1, 1, 1)
plt <- function(ci, k, l){
n <- c()
for(i in 1:n){
c[i] <- ci[[i]][k,l]
}
plot(c)
}
plt(ci1, 1, 1)
plt <- function(ci, k, l){
arr <- c()
for(i in 1:n){
arr[i] <- ci[[i]][k,l]
}
plot(arr)
}
plt(ci1, 1, 1)
plt <- function(ci, k, l){
arr <- c()
for(i in 1:n){
arr[i] <- ci[[i]][k,l]
}
plt <- function(ci, k, l){
arr <- c()
for(i in 1:n){
arr[i] <- ci[[i]][k,l]
}
hist(arr)
}
plt(ci1, 1, 1)
for(i)}
}
plt <- function(ci, k, l){
arr <- c()
for(i in 1:n){
arr[i] <- ci[[i]][k,l]
}
hist(arr)
}
plt(ci1, 1, 1)
plt(ci1, 1, 2)
plt(ci1, 2, 2)
fit.params1
fit.params1[1]
fit.params1[1]
fit.params1[1, 1]
fit.params1[1][1]
fit.params1[1]
fit.params1[1][1,]
fit.params1[1, 1,]
fit.params1[1,]
fit.params1[1]
fit.params1[1][1]
fit.params1[1][1][1]
fit.params1[1][1, 1]
dim(fit.params1[1])
fit.params1[1]$
a
fit.params1[1]
fit.params1[1, x2]
fit.params1[1, , x2]
fit.params1[x2]
fit.params1[2]
fit.params1
fit.params1[[2]]
fit.params1[[2]][1, 1]
fit.params1[[2]][, 1]
fit.params1[[2]][, 1] %*% dataset1[[1]]
fit.params1[[2]][, 1] %*% dataset1[[1]]
dataset1[[1]]
dataset1[1]
dataset1
# L1-loss
# Compare fitted values with real
function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
print(fit.params)
}
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
bootstrap(datasets1[[1]], B)
# L1-loss
# Compare fitted values with real
bootstrap <- function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
print(fit.params)
}
bootstrap(datasets1[[1]], B)
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
# L1-loss
# Compare fitted values with real
bootstrap <- function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
data <- matrix(1, nrow = length(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
err <- 0
for (i in 1:B){
r <- data %*% fit.params[, i]
err <- err + (dataset$y - r)^2
}
err <- err/B
print(err)
}
bootstrap(datasets1[[1]], B)
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
datasets1[[1]]
datasets1[[1]]$x2
data <- matrix(1, nrow = length(datasets[[1]]), ncol = 3)
data
dataset <- datasets[[1]]
data <- matrix(1, nrow = length(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
dataset
dataset <- datasets1[[1]]
data <- matrix(1, nrow = length(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
length(data[,2])
data
dataset
length(dataset)
length(nrows(dataset))
length(nrow(dataset))
nrow(dataset)
# L1-loss
# Compare fitted values with real
bootstrap <- function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
data <- matrix(1, nrow = nrow(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
err <- 0
for (i in 1:B){
r <- data %*% fit.params[, i]
err <- err + (dataset$y - r)^2
}
err <- err/B
print(err)
}
bootstrap(datasets1[[1]], B)
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
# L1-loss
# Compare fitted values with real
bootstrap <- function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
data <- matrix(1, nrow = nrow(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
err <- 0
for (i in 1:B){
r <- data %*% fit.params[, i]
err <- err + (dataset$y - r)^2
}
err <- err/B
c(fit.params, ci, err)
}
bootstrap(datasets1[[1]], B)
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
# L1-loss
# Compare fitted values with real
bootstrap <- function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
data <- matrix(1, nrow = nrow(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
err <- 0
for (i in 1:B){
r <- data %*% fit.params[, i]
err <- err + (dataset$y - r)^2
}
err <- err/B
data.frame(params = fit.params, ci=ci, err=err)
}
bootstrap(datasets1[[1]], B)
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
# L1-loss
# Compare fitted values with real
bootstrap <- function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
data <- matrix(1, nrow = nrow(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
err <- 0
for (i in 1:B){
r <- data %*% fit.params[, i]
err <- err + (dataset$y - r)^2
}
err <- err/B
list(params = fit.params, ci=ci, err=err)
}
bootstrap(datasets1[[1]], B)
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
# L1-loss
# Compare fitted values with real
bootstrap <- function(dataset, B){
# Fit parameters using bootstrap
fit.params <- obst.est(dataset, B)
# Confidence interval
ci <- obst.ci(fit.params, dataset, alpha)
# Error
data <- matrix(1, nrow = nrow(dataset), ncol = 3)
data[, 2] <- dataset$x2
data[, 3] <- dataset$x3
err <- 0
for (i in 1:B){
r <- data %*% fit.params[, i]
err <- err + (dataset$y - r)^2
}
err <- err/B
list(params = fit.params, ci=ci, err=err)
}
lst <- bootstrap(datasets1[[1]], B)
hist(lst$err)
#fit.params1 <- obst.est(dataset1, B)
#m <- cbind(cbind(matrix(1, nrow = length(x2), ncol = 1), x2), x3)
#dim(m %*% t(fit.params1))
#fit.params1
load(url("http://stat.ethz.ch/~maathuis/teaching/fall13/homework2.Rdata"))
cor.4.6
res1 <- factanal(covmat=cor.4.6, factors=2, rotation="none", n.obs=220)
round(res1$loadings,2)
res1 <- factanal(covmat=cor.4.6, factors=1, rotation="none", n.obs=220)
round(res1$loadings,2)
res1 <- factanal(covmat=cor.4.6, factors=5, rotation="none", n.obs=220)
round(res1$loadings,2)
res1 <- factanal(covmat=cor.4.6, factors=5, rotation="none", n.obs=220)
res1 <- factanal(covmat=cor.4.6, factors=4, rotation="none", n.obs=220)
res1 <- factanal(covmat=cor.4.6, factors=3, rotation="none", n.obs=220)
round(res1$loadings,2)
res1 <- factanal(covmat=cor.4.6, factors=2, rotation="none", n.obs=220)
round(res1$loadings,2)
cor.4.6
res1$correlation
res1$uniquenesses
res1$factors
res1$dof
res1 <- factanal(covmat=cor.4.6, factors=3, rotation="none", n.obs=220)
res1$dof
res1 <- factanal(covmat=cor.4.6, factors=2, rotation="none", n.obs=220)
round(res1$loadings,2)
plot(res1$loadings)
res2 <- varimax(res1$loadings,normalize=FALSE)
res2 <- varimax(res1$loadings,normalize=FALSE)
abline(0, res2$rotmat[2,1]/res2$rotmat[1,1], lty=2)
abline(0, res2$rotmat[2,2]/res2$rotmat[1,2], lty=2)
plot(res1$loadings, xlim = c(-5, 5), ylim = c(-5, 5))
plot(res1$loadings, xlim = c(-2, 2), ylim = c(-2, 2))
res2 <- varimax(res1$loadings,normalize=FALSE)
abline(0, res2$rotmat[2,1]/res2$rotmat[1,1], lty=2)
abline(0, res2$rotmat[2,2]/res2$rotmat[1,2], lty=2)
?abline
res2
View(cor.4.6)
View(cor.4.7)
View(data)
View(cor.4.6)
load(url("http://stat.ethz.ch/~maathuis/teaching/spring15/homework3.Rdata"))
cor.4.7
load("/Users/ales/Desktop/ETH/AppliedMultivariateStatistics/Rcode/homework3_od_nje.Rdata")
View(data)
View(cor.4.7)
View(cor.4.6)
eigen(cor.4.7)
eig <- eigen(cor.4.7)
plot(eig$values)
eig
eig[, 1:2]
eig[, 1]
eig <- eigen(cor.4.7)
# Which eigen vestors are the most important? Check eigen values
plot(eig$values)
# From the plot it's usefull to take first two principal components
eig[, 1]
eig[1]
eig[1:2]
eig
eig$vectors[, 1:2]
PI
?log2
p <- qplot(
xlab = "Number of hidden layers",
ylab = "% of peak performance", geom = "path",
ylim = c(0, 100)) +
theme(axis.title.y = element_text(angle=y.axis.angle)) +
geom_hline(yintercept = 100, col = 2) +
geom_hline(yintercept = 100 * (old_peak_performance/peak_performance) , col = "grey") +
annotate("text", label = "vec. peak performance", x = 600, y = 98, size = 4, colour = "red") +
annotate("text", label = "old peak performance", x = 600, y = 23, size = 4, colour = "grey") +
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
current_dir
getwd()
getwd()
setwd("./Desktop")
setwd("../")
setwd("./Desktop")
getwd()
setwd("../")
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
setwd(getwd())
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
getwd()
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
p
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
p <- qplot(1:800, 100 * (old_peak_performance/peak_performance),  col = "grey",
xlab = "Number of hidden layers",
ylab = "% of peak performance", geom = "path",
ylim = c(0, 100)) +
theme(axis.title.y = element_text(angle=y.axis.angle)) +
geom_hline(yintercept = 100, col = 2) +
annotate("text", label = "vec. peak performance", x = 600, y = 98, size = 4, colour = "red") +
annotate("text", label = "old peak performance", x = 600, y = 23, size = 4, colour = "grey")
p
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
p
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
source('~/Desktop/GIT/FastNumericalCode/rbm/plot_compare.R')
p
q <- qplot(1:800, 5)
q
qplot(1:800, 5)
qplot(1:800, 5)
qplot(1:800, 5)
plot(1:10, 1:10)
